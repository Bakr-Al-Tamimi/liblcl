/*
   The code is automatically generated by the genBind tool. 
   Author: ying32
   https://github.com/ying32  
*/

##
##
#ifndef _LIBLCL_H
#define _LIBLCL_H
##
#ifdef __cplusplus
//extern "C" {
#define CChar const
#else
#define CChar
#endif
##
#ifdef __GNUC__
   // #pragma GCC diagnostic ignored "-Wint-to-pointer-cast"
#endif
##
#include <stdint.h>
#include <stdio.h>
#include <assert.h>
##
#ifdef __GNUC__
#include <pthread.h>
#endif
##
#ifdef _WIN32
    #include<Windows.h>
    #define LCLAPI __stdcall
#else
    #include <dlfcn.h>
    #include <stddef.h>
    #include <stdbool.h>
    // __cdecl 默认
    #define LCLAPI
    #define TRUE 1
    #define FALSE 0
#endif
##
#ifndef NULL
    #define NULL 0
#endif
##
//#ifdef __APPLE__
//    #include <Cocoa/Cocoa.h>
//#endif
##
##
##
// 非Windows下的类型定义
#ifndef _WIN32
    typedef int32_t BOOL;
#endif
##
#ifdef __linux__
    typedef void* PGdkWindow;
    typedef uintptr_t TXId;
    typedef void* PGtkFixed;
#endif
##
#ifdef __APPLE__
    //#include <Cocoa/Cocoa.h>
    typedef void* MyNSWindow;
#endif
##
// printf("GetFunc: %s=%p\n", ""#name"", p##name);
##
// 获取dll函数地址
#define GET_FUNC_ADDR(name) \
if(!p##name) \
   p##name = get_proc_addr(""#name""); \
assert(p##name != NULL);
##
// 定义dll函数指针
#define DEFINE_FUNC_PTR(name) \
static void* p##name;
##
// 转换参数
#define COV_PARAM(name) \
(uintptr_t)name
##
##
/*--------------------常量定义--------------------*/
{{range $el := .Consts}}
  {{if not (isEmpty $el.Name)}}
    {{if eq $el.Name "CF_TEXT"}}
#ifndef _WIN32
##
    {{end}}
#define {{$el.Name}}  {{$el.Value}}{{if not (isEmpty $el.Value2)}} + {{$el.Value2}}{{end}}{{if not (isEmpty $el.Comment)}} // {{html $el.Comment}}{{end}}
  {{else}}
##
// {{html $el.Comment}}
  {{end}}
    {{if eq $el.Name "CF_LOCALE"}}
##
#endif
    {{end}}
{{end}}
##
/*--------------------枚举定义/集合定义--------------------*/
// 集合定义
typedef uint32_t TSet;
##
{{range $el := .Types}}
  {{if eq $el.Kind "enum"}}
##
typedef enum {
      {{range $enum := $el.Enums}}
    {{$enum.Name}}{{if not (isEmpty $enum.Value)}} = {{$enum.Value}}{{end}},{{if not (isEmpty $enum.Comment)}} // {{html $enum.Comment}}{{end}}
      {{end}}
} {{$el.Name}};
  {{else if eq $el.Kind "set"}}
##
typedef TSet {{$el.Name}};
  {{end}}
{{end}}


##
/*--------------------类型定义--------------------*/
{{/* 基础类型定义 */}}

{{range $tidex, $el := .BaseTypes}}
  {{if isEmpty $el.FieldArch}}
    {{if eq $el.Kind "struct"}}
##
typedef struct {{$el.Name}} {
      {{range $field := $el.Fields}}
    {{covType $field.Type}} {{covKeyword $field.Name}}{{if $field.IsArr}}[{{$field.ArrLength}}]{{end}};
      {{end}}
} {{$el.Name}};
  {{else if eq $el.Kind "type"}}
      {{if ne $el.Name "TSet"}}
        {{if or (or (eq $el.Name "HWND") (eq $el.Name "HPALETTE")) (eq $el.Name "LPCWSTR")}}
##
#ifndef _WIN32
##
        {{end}}
##
typedef {{covType $el.Type}} {{$el.Name}};

        {{if or (or (eq $el.Name "HGLOBAL") (eq $el.Name "LRESULT")) (eq $el.Name "HCURSOR")}}
##
#endif
##
        {{end}}
      {{end}}
    {{end}}
  {{end}}
{{end}}

{{/* 类型，不要arc的 */}}
{{range $el := .Types}}
  {{if isEmpty $el.FieldArch}}
    {{if eq $el.Kind "struct"}}
##
typedef struct {{$el.Name}} {
      {{range $field := $el.Fields}}
    {{covType $field.Type}} {{covKeyword $field.Name}}{{if $field.IsArr}}[{{$field.ArrLength}}]{{end}};
      {{end}}
} {{$el.Name}};
  {{else if eq $el.Kind "type"}}
##
typedef {{covType $el.Type}} {{$el.Name}};
    {{end}}
  {{end}}
{{end}}
##
{{/* 类型，arc的 */}}
#if defined(_WIN64) || defined(__x86_64__)
{{range $el := .BaseTypes}}
  {{if eq $el.FieldArch "amd64"}}
    {{if eq $el.Kind "struct"}}
##
typedef struct {{$el.Name}} {
      {{range $field := $el.Fields}}
    {{covType $field.Type}} {{covKeyword $field.Name}}{{if $field.IsArr}}[{{$field.ArrLength}}]{{end}};
      {{end}}
} {{$el.Name}};
    {{end}}
  {{end}}
{{end}}
#else
{{range $el := .BaseTypes}}
  {{if eq $el.FieldArch "i386"}}
    {{if eq $el.Kind "struct"}}
##
typedef struct {{$el.Name}} {
      {{range $field := $el.Fields}}
    {{covType $field.Type}} {{covKeyword $field.Name}}{{if $field.IsArr}}[{{$field.ArrLength}}]{{end}};
      {{end}}
} {{$el.Name}};
    {{end}}
  {{end}}
{{end}}
#endif

##
##
/*--------------------类的定义--------------------*/
{{range $el := .Objects}}
typedef void* {{$el.ClassName}};
{{end}}
typedef void* TStream;

##
/*--------------------事件定义--------------------*/
{{range $el := .Events}}
// void ({{range $idx, $ps := $el.Params}}{{if gt $idx 0}}, {{end}}{{if and (eq $el.Name "TDropFilesEvent") (eq $ps.Type "int")}}intptr_t{{else}}{{covType $ps.Type}}{{end}}{{if $ps.IsVar}}*{{end}} {{$ps.Name}}{{end}})
typedef void(*{{$el.Name}})({{range $idx, $ps := $el.Params}}{{if gt $idx 0}}, {{end}}{{if and (eq $el.Name "TDropFilesEvent") (eq $ps.Type "int")}}intptr_t{{else}}{{covType $ps.Type}}{{end}}{{if $ps.IsVar}}*{{end}}{{end}});
##
{{end}}
##


##
##
// 集合加法，val...中存储为位的索引，下标为0
TSet Include(TSet s, uint8_t val) {
    return (TSet)(s | (1 {{html "<<"}} val));
}
//TSet Include(TSet s, ...) {
//    uint32_t r = (uint32_t)s;
//    va_list varlist;
//    va_start(varlist, s);
//    uint8_t val;
//    while ((val = va_arg(varlist, int)) != -1) {
//        r |= (1 {{html "<<"}} (uint8_t)val);
//    }
//    va_end(varlist);
//    return (TSet)r;
//}
##
// 集合减法，val...中存储为位的索引，下标为0
TSet Exclude(TSet s, uint8_t val) {
    return (TSet)(s & (~(1 {{html "<<"}} val)));
}
//TSet Exclude(TSet s, ...) {
//    uint32_t r = (uint32_t)s;
//    va_list varlist;
//    va_start(varlist, s);
//    uint8_t val;
//    while ((val = va_arg(varlist, int)) != -1) {
//        r &= ~(1 {{html "<<"}} (uint8_t)val);
//    }
//    va_end(varlist);
//    return (TSet)r;
//}
##
// 集合类型的判断，val表示位数，下标为0
BOOL InSet(uint32_t s, uint8_t val) {
    if ((s&(1 {{html "<<"}} val)) != 0) {
        return TRUE;
    }
    return FALSE;
}
##
##
// liblcl句柄
static uintptr_t libHandle;
##
// 用于处理异常的模拟call
typedef uint64_t(LCLAPI *MYSYSCALL)(void*, intptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t);
##
// 函数指针
static MYSYSCALL pMySyscall;
##
// 异常处理函数实体
#define MySyscall(addr, len, a1, a2 , a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) \
    pMySyscall((void*)addr, (intptr_t)len, COV_PARAM(a1), COV_PARAM(a2), COV_PARAM(a3), COV_PARAM(a4), COV_PARAM(a5), COV_PARAM(a6), COV_PARAM(a7), COV_PARAM(a8), COV_PARAM(a9), COV_PARAM(a10), COV_PARAM(a11), COV_PARAM(a12))
##
// 全局实例类定义
TApplication Application; // 应用程序
TScreen Screen;           // 屏幕
TMouse	Mouse;            // 鼠标
TClipboard	Clipboard;    // 剪切板
TPrinter Printer;         // 打印机
##
// 全局互斥锁
#ifdef __GNUC__
static pthread_mutex_t threadSyncMutex;
#else
static RTL_CRITICAL_SECTION threadSyncMutex;
#endif
##
// 初始liblcl库
static void init_lib_lcl();
// 反向初始liblcl库
static void un_init_lib_lcl();
##
##
// 获取过程地址
static void* get_proc_addr(const char *name) {
#ifdef _WIN32
    return (void*)GetProcAddress((HMODULE)libHandle, name);
#else
    return (void*)dlsym((void*)libHandle, name);
#endif
}
##
// 加载库
BOOL load_liblcl(const char *name) {
    if(libHandle > 0)
        return TRUE;
#ifdef _WIN32
    libHandle = (uintptr_t)LoadLibraryA(name);
#else
    libHandle = (uintptr_t)dlopen(name, RTLD_LAZY|RTLD_GLOBAL);
#endif
    if(libHandle > 0) {
         pMySyscall = (MYSYSCALL)get_proc_addr("MySyscall");
         // 初始库
         init_lib_lcl();
    }
    return libHandle > 0;
}
##
// 关闭库
void close_liblcl() {
    if(libHandle > 0) {
	#ifdef _WIN32
	    FreeLibrary((HMODULE)libHandle);
	#else
	    dlclose((void*)libHandle);
	#endif
        libHandle = 0;
        un_init_lib_lcl();
    }
}
##

/*--------------------一些其它函数--------------------*/
{{range $el := .Functions}}

{{if ne $el.Name "DMove"}}

{{if eq $el.Name "DSendMessage"}}
#ifndef _WIN32
##
{{end}}
{{if eq $el.Name "DCreateURLShortCut"}}
#ifdef _WIN32
##
{{end}}
{{if eq $el.Name "GtkWidget_GetGtkFixed"}}
##
#ifdef __linux__
##
{{end}}
{{if eq $el.Name "NSWindow_FromForm"}}
##
#ifdef __APPLE__
##
{{end}}

##
DEFINE_FUNC_PTR({{$el.Name}})
{{if isEmpty $el.Return}}void{{else}}{{covType $el.Return}}{{end}} {{delDChar $el.Name}}({{range $idx, $ps := $el.Params}}{{if gt $idx 0}}, {{end}}{{if eq $ps.Type "string"}}CChar {{end}}{{covType $ps.Type}}{{if $ps.IsVar}}*{{end}} {{$ps.Name}}{{end}}) {
    GET_FUNC_ADDR({{$el.Name}})
    {{if not (isEmpty $el.Return)}}return ({{covType $el.Return}}){{end}}MySyscall(p{{$el.Name}}, {{len $el.Params}}{{range $idx, $ps := $el.Params}}, {{$ps.Name}}{{end}}{{cPsZero $el.Params}});
}


{{if or (or (or (eq $el.Name "DWindowFromPoint") (eq $el.Name "DCreateShortCut")) (eq $el.Name "NSWindow_FromForm")) (eq $el.Name "GtkWidget_Window")}}
##
#endif
##
{{end}}
{{end}}
{{end}}


/*--------------------类成员函数--------------------*/

{{range $obj := .Objects}}
##
// -------------------{{$obj.ClassName}}-------------------
  {{range $el := $obj.Methods}}

##
DEFINE_FUNC_PTR({{$el.Name}})

{{if isEmpty $el.Return}}void{{else}}{{covType $el.Return}}{{end}} {{$el.Name}}({{range $idx, $ps := $el.Params}}{{if gt $idx 0}}, {{end}}{{if eq $ps.Type "string"}}CChar {{end}}{{covType $ps.Type}}{{if $ps.IsVar}}*{{end}} {{$ps.Name}}{{end}}) {
    GET_FUNC_ADDR({{$el.Name}})
    {{if not (isEmpty $el.Return)}}return ({{covType $el.Return}}){{end}}MySyscall(p{{$el.Name}}, {{len $el.Params}}{{range $idx, $ps := $el.Params}}, {{$ps.Name}}{{end}}{{cPsZero $el.Params}});
}
  {{end}}
{{end}}
##
##

/* ------------------函数重定义------------------------------- */
static inline char* GetFPStringArrayMember(void* P, intptr_t AIndex) {
    return GetStringArrOf(P, AIndex);
}


##
// 不知道有什么方法可以简化下
typedef void(*SYSCALL0)();
typedef void(*SYSCALL1)(intptr_t);
typedef void(*SYSCALL2)(intptr_t, uintptr_t);
typedef void(*SYSCALL3)(intptr_t, uintptr_t, uintptr_t);
typedef void(*SYSCALL4)(intptr_t, uintptr_t, uintptr_t, uintptr_t);
typedef void(*SYSCALL5)(intptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t);
typedef void(*SYSCALL6)(intptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t);
typedef void(*SYSCALL7)(intptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t);
typedef void(*SYSCALL8)(intptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t);
typedef void(*SYSCALL9)(intptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t);
typedef void(*SYSCALL10)(intptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t);
typedef void(*SYSCALL11)(intptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t);
typedef void(*SYSCALL12)(intptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t);
##
##
// getParam 从指定索引和地址获取事件中的参数
#define getParamOf(index, ptr) \
 (*((uintptr_t*)((uintptr_t)ptr + (uintptr_t)index*sizeof(uintptr_t))))
##
##
// 事件回调
static void* LCLAPI doEventCallbackProc(void* f, void* args, long argCount) {
##
	// 获取参数的宏
	#define _A_(index) \
	   getParamOf(index, args)
##
    switch (argCount) {
    case 0:  ((SYSCALL0) (f))(); break;
    case 1:  ((SYSCALL1) (f))(_A_(0)); break;
    case 2:  ((SYSCALL2) (f))(_A_(0), _A_(1)); break;
    case 3:  ((SYSCALL3) (f))(_A_(0), _A_(1), _A_(2)); break;
    case 4:  ((SYSCALL4) (f))(_A_(0), _A_(1), _A_(2), _A_(2)); break;
    case 5:  ((SYSCALL5) (f))(_A_(0), _A_(1), _A_(2), _A_(3), _A_(4)); break;
    case 6:  ((SYSCALL6) (f))(_A_(0), _A_(1), _A_(2), _A_(3), _A_(4), _A_(5)); break;
    case 7:  ((SYSCALL7) (f))(_A_(0), _A_(1), _A_(2), _A_(3), _A_(4), _A_(5), _A_(6)); break;
    case 8:  ((SYSCALL8) (f))(_A_(0), _A_(1), _A_(2), _A_(3), _A_(4), _A_(5), _A_(6), _A_(7)); break;
    case 9:  ((SYSCALL9) (f))(_A_(0), _A_(1), _A_(2), _A_(3), _A_(4), _A_(5), _A_(6), _A_(7), _A_(8)); break;
    case 10: ((SYSCALL10)(f))(_A_(0), _A_(1), _A_(2), _A_(3), _A_(4), _A_(5), _A_(6), _A_(7), _A_(8), _A_(9)); break;
    case 11: ((SYSCALL11)(f))(_A_(0), _A_(1), _A_(2), _A_(3), _A_(4), _A_(5), _A_(6), _A_(7), _A_(8), _A_(9), _A_(10)); break;
    case 12: ((SYSCALL12)(f))(_A_(0), _A_(1), _A_(2), _A_(3), _A_(4), _A_(5), _A_(6), _A_(7), _A_(8), _A_(9), _A_(10), _A_(11)); break;
    }
    return NULL;
}
##
##
// 消息回调
static void* LCLAPI doMessageCallbackProc(void* f, void* msg) {
   ((void(*)(void*))f)(msg);
    return NULL;
}
##
// 线程同步过程
static TThreadProc threadSyncProc;
// 线程同步回调
static void* LCLAPI doThreadSyncCallbackProc() {
    if (threadSyncProc) {
        ((TThreadProc)threadSyncProc)();
        threadSyncProc = NULL;
    }
    return NULL;
}
##
// 线程同步方法
// 无参数，无返回值的一个函数
void ThreadSync(TThreadProc fn) {
    // 加锁
#ifdef __GNUC__
    pthread_mutex_lock(&threadSyncMutex);
#else
    EnterCriticalSection(&threadSyncMutex);
#endif
    threadSyncProc = fn;
    Synchronize(FALSE);
    threadSyncProc = NULL;
#ifdef __GNUC__
    pthread_mutex_unlock(&threadSyncMutex);
#else
    LeaveCriticalSection(&threadSyncMutex);
#endif
##
}
##
#define GET_CALLBACK(name) \
  (void*)&name
##
static void init_lib_lcl() {
#ifdef __GNUC__
    pthread_mutex_init(&threadSyncMutex, NULL);
#else
    InitializeCriticalSection(&threadSyncMutex);
#endif
##
    // 设置事件的回调函数
	SetEventCallback(GET_CALLBACK(doEventCallbackProc));
	// 消息回调
	SetMessageCallback(GET_CALLBACK(doMessageCallbackProc));
	// 线程同步回调
	SetThreadSyncCallback(GET_CALLBACK(doThreadSyncCallbackProc));
##
	Application = Application_Instance();
	Screen = Screen_Instance();
	Mouse = Mouse_Instance();             // 鼠标
	Clipboard = Clipboard_Instance();     // 剪切板
	Printer = Printer_Instance();         // 打印机
##
}
##
static void un_init_lib_lcl() {
#ifdef __GNUC__
    pthread_mutex_destroy(&threadSyncMutex);
#else
    DeleteCriticalSection(&threadSyncMutex);
#endif
}
##
//#ifdef __cplusplus
//}
//#endif
##
#endif // _LIBLCL_H
