#[ 
   The code is automatically generated by the genBind tool. 
   Author: ying32
   https://github.com/ying32  
]#
##
{.deadCodeElim: on.}
##
# DLL
when defined(windows):
  {.push, callconv: stdcall.}
else:
  {.push, callconv: cdecl.}
##
when defined(windows):
  const dllname = "liblcl.dll"
elif defined(macosx):
  const dllname = "liblcl.dylib"
else:
  const dllname = "liblcl.so"    
##
import types
##
##
{{range $el := .Functions}}
{{if eq $el.Platform "windows"}}when defined(windows):{{end}}
{{if eq $el.Platform "linux,macos"}}when not defined(windows):{{end}}
{{if eq $el.Platform "macos"}}when defined(macos):{{end}}
{{if eq $el.Platform "linux"}}when defined(linux):{{end}}
{{if ne $el.Platform "all"}}  {{end}}proc {{$el.Name}}*({{range $idx, $ps := $el.Params}}{{if gt $idx 0}}, {{end}}{{$ps.Name}}: {{if not (isObject $ps.Type)}}{{if $ps.IsVar}}var {{end}}{{covType $ps.Type}}{{else}}pointer{{end}}{{end}}){{if not (isEmpty $el.Return)}}: {{if not (isObject $el.Return)}}{{covType $el.Return}}{{else}}pointer{{end}}{{end}} {.importc: "{{$el.Name}}", dynlib: dllname.}
{{end}}
##
##
{{range $el := .Objects}}
# ----------------- {{$el.ClassName}} ----------------------
{{range $fn := $el.Methods}}
proc {{$fn.Name}}*({{range $idx, $ps := $fn.Params}}{{if gt $idx 0}}, {{end}}{{$ps.Name}}: {{if not (isObject $ps.Type)}}{{if $ps.IsVar}}var {{end}}{{covType $ps.Type}}{{else}}pointer{{end}}{{end}}){{if not (isEmpty $fn.Return)}}: {{if not (isObject $fn.Return)}}{{covType $fn.Return}}{{else}}pointer{{end}}{{end}} {.importc: "{{$fn.Name}}", dynlib: dllname.}
{{end}}
{{end}}

##
# 开始 
##
# 普通事件回调函数
proc doEventCallbackProc(f: pointer, args: pointer, argCount: int32): uint =
##
  # args为一个数组，长度为argCount, argCount最大为12
  var val = proc(index: int): pointer {.nimcall.} =
    return cast[pointer](cast[ptr uint](cast[uint](args) + cast[uint](index * sizeof(int)))[])
##
  # echo("doEventCallbackProc: f: ", cast[uint](f), ", args: ",cast[uint](args), ", count: ", argCount)
##
  case argCount
  of 0: 
    cast[proc(){.nimcall.}](f)()
  of 1:
    cast[proc(a1:pointer) {.nimcall.} ](f)(val(0))
  of 2:
    cast[proc(a1,a2:pointer) {.nimcall.} ](f)(val(0), val(1))
  of 3:
    cast[proc(a1,a2,a3:pointer) {.nimcall.} ](f)(val(0), val(1), val(2))
  of 4:
    cast[proc(a1,a2,a3,a4:pointer) {.nimcall.} ](f)(val(0), val(1), val(2), val(3))
  of 5:
    cast[proc(a1,a2,a3,a4,a5:pointer) {.nimcall.} ](f)(val(0), val(1), val(2), val(3), val(4))
  of 6:
    cast[proc(a1,a2,a3,a4,a5,a6:pointer) {.nimcall.} ](f)(val(0), val(1), val(2), val(3), val(4), val(5))
  of 7:
    cast[proc(a1,a2,a3,a4,a5,a6,a7:pointer) {.nimcall.} ](f)(val(0), val(1), val(2), val(3), val(4), val(5), val(6))
  of 8:
    cast[proc(a1,a2,a3,a4,a5,a6,a7,a8:pointer) {.nimcall.} ](f)(val(0), val(1), val(2), val(3), val(4), val(5), val(6), val(7))
  of 9:
    cast[proc(a1,a2,a3,a4,a5,a6,a7,a8,a9:pointer) {.nimcall.} ](f)(val(0), val(1), val(2), val(3), val(4), val(5), val(6), val(7), val(8))
  of 10:
    cast[proc(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10:pointer) {.nimcall.} ](f)(val(0), val(1), val(2), val(3), val(4), val(5), val(6), val(7), val(8), val(9))
  of 11:
    cast[proc(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11:pointer) {.nimcall.} ](f)(val(0), val(1), val(2), val(3), val(4), val(5), val(6), val(7), val(8), val(9), val(10))
  of 12:  
    cast[proc(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12:pointer) {.nimcall.} ](f)(val(0), val(1), val(2), val(3), val(4), val(5), val(6), val(7), val(8), val(9), val(10), val(11))
  else:
    echo("There are more than 12 parameters.")
##
  return 0
##
# 窗口消息专用回调
proc doMessageCallbackProc(f: pointer, msg: pointer): uint =
  # 这里要转发消息
  cast[proc(a1:pointer) {.nimcall.} ](f)(msg)
  return 0
##
# 线程同步专用回调
proc doThreadSyncCallbackProc(): uint =
  return 0
##
# set callback
SetEventCallback(cast[pointer](doEventCallbackProc))
SetMessageCallback(cast[pointer](doMessageCallbackProc))
SetThreadSyncCallback(cast[pointer](doThreadSyncCallbackProc))

